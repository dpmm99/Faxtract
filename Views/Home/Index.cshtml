@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
@{
    ViewData["Title"] = "Work Processor";
}

<div class="container">
    <form method="post" enctype="multipart/form-data" asp-controller="Home" asp-action="UploadFile">
        <div asp-validation-summary="All" class="text-danger"></div>
        <input type="file" name="file" accept=".txt" />
        <button type="submit">Upload</button>
    </form>

    <div class="status">
        <p>Processed: <span id="processed">0</span></p>
        <p>Remaining: <span id="remaining">0</span></p>
        <p>Tokens Generated: <span id="tokensGenerated">0</span>/<span id="maxTokens">0</span></p>
        <p>Processing Speed: <span id="tokensPerSecond">-</span> tokens/sec</p>
    </div>

    <div id="currentWork"></div>
</div>

@section Scripts {
    <script src="~/lib/signalr/signalr.js"></script>
    <script>
        const connection = new signalR.HubConnectionBuilder()
            .withUrl("/workhub")
            .withAutomaticReconnect()
            .build();

        // Track complete responses for each chunk using position as identifier
        let responseHistory = new Map();
        let activeChunkIds = new Set();

        // Map to track DOM elements for each work item
        const workItemElements = new Map();

        connection.on("UpdateStatus", (processed, remaining, currentWork, tokensPerSecond, totalTokens, maxTokens) => {
            // Update status counters directly
            document.getElementById("processed").textContent = processed;
            document.getElementById("remaining").textContent = remaining;
            document.getElementById("tokensGenerated").textContent = totalTokens || "0";
            document.getElementById("maxTokens").textContent = maxTokens || "0";
            document.getElementById("tokensPerSecond").textContent =
                tokensPerSecond ? tokensPerSecond.toFixed(1) : "-";

            const workDiv = document.getElementById("currentWork");

            // Get current chunk identifiers
            const currentChunkIds = new Set();
            currentWork.forEach(w => {
                if (w.id && w.id.startPosition !== undefined && w.id.endPosition !== undefined) {
                    currentChunkIds.add(`${w.id.startPosition}-${w.id.endPosition}`);
                }
            });

            // Check if we have a new batch
            const newBatchDetected = !setsEqual(activeChunkIds, currentChunkIds);
            if (newBatchDetected) {
                // Clear previous elements and history
                workDiv.innerHTML = '';
                workItemElements.clear();
                responseHistory.clear();
                activeChunkIds = currentChunkIds;
            }

            // Process each work item
            currentWork.forEach(w => {
                const key = w.id && w.id.startPosition !== undefined ?
                    `${w.id.startPosition}-${w.id.endPosition}` :
                    JSON.stringify(w.id);

                const newToken = w.response ?? '';

                // Get or create work item element - to optimize performance by making the minimum possible DOM manipulations
                let workItemEl = workItemElements.get(key);
                if (!workItemEl) {
                    // Create new work item elements
                    workItemEl = document.createElement('div');
                    workItemEl.className = 'work-item';

                    const statusEl = document.createElement('div');
                    statusEl.className = 'status-line';
                    workItemEl.appendChild(statusEl);

                    const responseLabel = document.createElement('div');
                    responseLabel.textContent = 'Response:';
                    workItemEl.appendChild(responseLabel);

                    const responseEl = document.createElement('pre');
                    responseEl.className = 'response-content';
                    workItemEl.appendChild(responseEl);

                    workDiv.appendChild(workItemEl);
                    workItemElements.set(key, workItemEl);
                }

                // Update status
                const statusEl = workItemEl.querySelector('.status-line');
                statusEl.textContent = `Status: ${w.status}`;

                // Only append new tokens if processing isn't complete
                if (!w.status.includes("Processing complete") && newToken) {
                    // Get existing response or initialize
                    const existingResponse = responseHistory.get(key) ?? '';
                    const newResponse = existingResponse + newToken;
                    responseHistory.set(key, newResponse);

                    // Append just the new token to the pre element
                    const responseEl = workItemEl.querySelector('.response-content');
                    const textNode = document.createTextNode(newToken);
                    responseEl.appendChild(textNode);
                }
            });
        });

        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Helper function to compare sets
        function setsEqual(a, b) {
            if (a.size !== b.size) return false;
            for (const item of a) {
                if (!b.has(item)) return false;
            }
            return true;
        }

        connection.start();
    </script>

    <style>
        .container { max-width: 800px; margin: 20px auto; }
        .work-item { border: 1px solid #ddd; margin: 10px 0; padding: 10px; }
        .status { margin: 20px 0; }
        pre.response-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
            font-family: inherit;
            background-color: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
}