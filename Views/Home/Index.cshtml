@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
@{
    ViewData["Title"] = "Upload";
}

<div class="container">
    <div class="top-container">
        <form method="post" enctype="multipart/form-data" id="uploadForm">
            <div asp-validation-summary="All" class="text-danger"></div>
            <input type="file" name="files" accept=".txt" multiple />
            <button type="submit">Upload</button>
        </form>
        <div id="upload-status" class="mt-3"></div>

        <div class="status">
            <p>Processed: <span id="processed">0</span></p>
            <p>Remaining: <span id="remaining">0</span></p>
            <p>Tokens Generated: <span id="tokensGenerated">0</span></p>
            <p>Processing Speed: <span id="tokensPerSecond">-</span> tokens/sec</p>
        </div>
    </div>

    <div id="currentWork"></div>
</div>

@section Scripts {
    <script src="~/lib/signalr/signalr.js"></script>
    <script>
        const connection = new signalR.HubConnectionBuilder()
            .withUrl("/workhub")
            .withAutomaticReconnect()
            .build();

        // Add form submission handler to prevent default redirect
        document.getElementById('uploadForm').addEventListener('submit', function(e) {
            e.preventDefault();

            const formData = new FormData(this);
            const uploadStatus = document.getElementById('upload-status');
            uploadStatus.innerHTML = '<div class="alert alert-info">Uploading files...</div>';

            fetch('@Url.Action("UploadFile", "Home")', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    uploadStatus.innerHTML = `<div class="alert alert-success">${data.message}</div>`;
                    document.getElementById('uploadForm').elements.files.value = null;
                } else {
                    uploadStatus.innerHTML = `<div class="alert alert-danger">${data.message}</div>`;
                }
            })
            .catch(error => {
                uploadStatus.innerHTML = `<div class="alert alert-danger">Upload failed: ${error.message}</div>`;
            });
        });

        // Track complete responses for each chunk using position as identifier
        let responseHistory = new Map();
        let activeChunkIds = new Set();

        // Map to track DOM elements for each work item
        const workItemElements = new Map();

        connection.on("UpdateStatus", (processed, remaining, currentWork, tokensPerSecond, totalTokens) => {
            // Update status counters directly
            document.getElementById("processed").textContent = processed;
            document.getElementById("remaining").textContent = remaining;
            document.getElementById("tokensGenerated").textContent = totalTokens || "0";
            document.getElementById("tokensPerSecond").textContent =
                tokensPerSecond ? tokensPerSecond.toFixed(1) : "-";

            const workDiv = document.getElementById("currentWork");

            // Get current chunk identifiers
            const currentChunkIds = new Set();
            currentWork.forEach(w => {
                if (w.id && w.id.startPosition !== undefined && w.id.endPosition !== undefined) {
                    currentChunkIds.add(`${w.id.fileId || ''}-${w.id.startPosition}-${w.id.endPosition}`);
                }
            });

            // Check if we have a new batch
            const newBatchDetected = !setsEqual(activeChunkIds, currentChunkIds);
            if (newBatchDetected) {
                // Clear previous elements and history
                workDiv.innerHTML = '';
                workItemElements.clear();
                responseHistory.clear();
                activeChunkIds = currentChunkIds;
            }

            // Process each work item
            currentWork.forEach(w => {
                const key = w.id && w.id.startPosition !== undefined ?
                    `${w.id.fileId || ''}-${w.id.startPosition}-${w.id.endPosition}` :
                    JSON.stringify(w.id);

                const newToken = w.response ?? '';

                // Get or create work item element - to optimize performance by making the minimum possible DOM manipulations
                let workItemEl = workItemElements.get(key);
                if (!workItemEl) {
                    // Create new work item elements
                    workItemEl = document.createElement('div');
                    workItemEl.className = 'work-item';

                    const statusEl = document.createElement('div');
                    statusEl.className = 'status-line';
                    statusEl.addEventListener('click', function() { // Make it toggleable
                        workItemEl.classList.toggle('collapsed');
                    });
                    workItemEl.appendChild(statusEl);

                    const responseLabel = document.createElement('div');
                    responseLabel.textContent = 'Response:';
                    responseLabel.className = 'response-label';
                    workItemEl.appendChild(responseLabel);

                    const responseEl = document.createElement('pre');
                    responseEl.className = 'response-content';
                    workItemEl.appendChild(responseEl);

                    workDiv.appendChild(workItemEl);
                    workItemElements.set(key, workItemEl);
                }

                // Update status
                const statusEl = workItemEl.querySelector('.status-line');
                statusEl.textContent = `Status: ${w.status}`;

                // Only append new tokens if processing isn't complete
                if (!w.status.includes("Processing complete") && newToken) {
                    // Get existing response or initialize
                    const existingResponse = responseHistory.get(key) ?? '';
                    const newResponse = existingResponse + newToken;
                    responseHistory.set(key, newResponse);

                    // Append just the new token to the pre element
                    const responseEl = workItemEl.querySelector('.response-content');
                    const textNode = document.createTextNode(newToken);
                    responseEl.appendChild(textNode);
                }
            });
        });

        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Helper function to compare sets
        function setsEqual(a, b) {
            if (a.size !== b.size) return false;
            for (const item of a) {
                if (!b.has(item)) return false;
            }
            return true;
        }

        connection.start();
    </script>

    <style>
        .container { margin: 20px auto; }
        .top-container { max-width: 25em; margin: 0 auto; }

        #currentWork {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
        }

        /* Updated work-item styling for side-by-side and collapsible */
        .work-item {
            border: 1px solid #ddd;
            margin: 0;
            padding: 10px;
            border-radius: 6px;
            flex: 1 1 calc(50% - 15px); /* Two items per row with gap */
            min-width: 20em;
            max-width: 55em;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }

        /* Make items full width on smaller screens */
        @@media (max-width: 768px) {
            .work-item
            {
                flex: 1 1 100%;
            }
        }

        /* Styling for collapsible elements */
        .status-line {
            font-weight: 500;
            color: #555;
            margin-bottom: 8px;
            cursor: pointer;
            padding: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 4px;
        }

            .status-line:hover {
                background-color: #f0f0f0;
            }

            .status-line::after {
                content: "\25BC";
                font-size: 0.8em;
                transition: transform 0.2s;
            }

        .work-item.collapsed .status-line::after {
            transform: rotate(-90deg);
        }

        .work-item.collapsed .response-label,
        .work-item.collapsed .response-content {
            display: none;
        }

        .status { margin: 20px 0; }
        pre.response-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
            font-family: inherit;
            background-color: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        #uploadForm {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        input[type="file"] {
            border: 1px solid #ddd;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            width: calc(100% - 16px); /*Take off the padding*/
        }

        button[type="submit"] {
            background-color: #4a6da7;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }

            button[type="submit"]:hover {
                background-color: #3a5a8a;
            }

        .alert {
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .alert-info {
            background-color: #e8f4fd;
            border-left: 4px solid #4a90e2;
            color: #1a5186;
        }

        .alert-success {
            background-color: #e9f7ef;
            border-left: 4px solid #2ecc71;
            color: #1d8348;
        }

        .alert-danger {
            background-color: #fdecea;
            border-left: 4px solid #e74c3c;
            color: #922b21;
        }

        .status {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 15px;
        }

            .status p {
                display: flex;
                justify-content: space-between;
                margin: 5px 0;
                padding: 5px 0;
                border-bottom: 1px solid #f0f0f0;
            }

                .status p:last-child {
                    border-bottom: none;
                }

        .mt-3 {
            margin-top: 15px;
        }
   </style>
}